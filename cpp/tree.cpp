#include <stdio.h>

/*
o表示高阶无穷小 u(x)=o(v(x)) lim(x->x0)(u(x)/v(x))=0
O表示有界量 u(x)=O(v(x)) lim(x->x0)|u(x)/v(x)|<=某个正数 某个正数<=lim(x->x0)|u(x)/v(x)|<=某个正数,则u(x)和v(x)是同阶无穷小
~表示等价无穷小 u(x)~v(x) lim(x->x0)(u(x)/v(x))=1

时间复杂度和空间复杂度是关于问题规模n的变化关系

满二叉树:除叶子节点外的所有节点的度均为2 n=2^h-1
完全二叉树:从左到右,从上到下,节点连续分布 n<=2^h-1

BST二叉查找树:
若左子树不空，则左子树上所有节点的值均小于它的根节点的值
若右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值
左、右子树也分别为二叉查找树

BST的树高为h，节点个数为n
查找、插入、删除时间复杂度:
平均情况：O(h)
最好情况：BST成为平衡二叉查找树，假设其包含最大满二叉树的节点数为m，其树高为h-1，则
m=2^(h-1)-1=>h=log(2)(m+1)+1
n>=m+1=>log(2)(n)>=log(2)(m+1)=>log(2)(m+1)=⌊log(2)(n)⌋
所以h=⌊log(2)(n)⌋+1=>O(h)=O(log(2)n)=O(logn)
这里的底数可以省略，他们都属于同一种时间复杂度/同阶无穷小，与n无关（分治法的思想，二分法的底数为2）
最坏情况：退化为单链表，O(n)

BST的空间复杂度为O(n)

平衡的目的:避免BST的最坏情况
平衡二叉查找树:可以是空树,任意一个节点的左子树和右子树都是平衡二叉树，并且高度之差的绝对值不超过1

红黑树:自平衡二叉查找树
1.每个节点都是红色和黑色
2.红黑树的根节点必须是黑色的
3.叶子节点NIL是黑色的
4.红色节点的两个子结点一定是黑色的
5.任意一个节点到它的每个叶子节点的路径都包含数量相同的黑色结点
5.1.如果一个节点有黑色子节点，那么该节点一定有两个子节点
*/

enum COLOR
{
    RED,
    BLACK
};
struct rbTree
{
    COLOR color;
    int key;
    struct rbTree *left;
    struct rbTree *right;
    struct rbTree *p;
};

int main()
{
    return 0;
}